# -*- coding: utf-8 -*-
"""portfolio_optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UCEXGcvvfcfmbb6sMpqRjqTEX7gncMLc
"""

import numpy as np
import pandas as pd
import time
import matplotlib.pyplot as plt


# Read MRet48.txt (expected returns)
MRet48 = pd.read_csv('MRet48.txt', header=None)

# Read Cov48.txt (covariance matrix)
Cov48 = pd.read_csv('Cov48.txt', delimiter='\s+', header=None)


# Read MRet48.txt (expected returns)
MRet79 = pd.read_csv('MRet79.txt', header=None)

# Read Cov48.txt (covariance matrix)
Cov79 = pd.read_csv('Cov79.txt', delimiter='\s+', header=None)


# The cost function for Markowitz portfolio problems
def cost_function(weights, covariance_matrix, landa, mue, mue_beta):
    return (0.5 * np.dot(weights.T, np.dot(covariance_matrix, weights)))  + landa * (mue_beta - np.dot(weights.T, mue))

## The gradient of cost function for Markowitz portfolio problems
def cost_function_gradient(weights, covariance_matrix, landa, mue):
    return np.dot(covariance_matrix, weights) - (landa * mue)


def frank_wolfe_markowitz(covariance_matrix, landa, mue, mue_beta):
    # find the total number of asset
    num_assets = len(mue)

    # Start with an initial allocation of 1/n weights
    weights = np.ones((num_assets,1)) / num_assets
    #print("initial weights shape is, ", weights.shape)

    # Defining convergence criteria here
    max_iterations = 20
    tolerance = 1e-3

    # Variables to store the cost function values
    cost_function_values = []

    # Start of the process
    start_time = time.time()

    # Definig the Identity matrix
    Indentity_matrix = np.identity(num_assets)

    for iteration in range(max_iterations):
        # Calculate the gradient of the cost function
        gradiant = cost_function_gradient(weights, covariance_matrix, landa, mue)
        #print(str(iteration) + " weights shape is, " + str(weights.shape))
        #print(str(iteration) + " gradiant shape is, " +  str(gradiant.shape))

        # find the direction
        indx = np.argmin(gradiant)
        direction = Indentity_matrix[indx]
        direction = direction.reshape((-1, 1))  # Ensure direction has shape (48, 1)
        #print("direction shape is, ", direction.shape)

        # Set the step size as it was suggested by the article
        step_size = 1.0 / (iteration + 2)

        # Update portfolio weights
        weights += step_size * (direction - weights)

        # Normalize the weights to ensure they sum to 1
        weights /= np.sum(weights)

        # Calculate the current cost function value
        cost_value = cost_function(weights, covariance_matrix, landa, mue, mue_beta)
        #print(type(cost_value), cost_value[0,0])
        cost_function_values.append(cost_value[0,0])

        # Check for convergence
        if np.linalg.norm(step_size * (direction - weights)) < tolerance:
            break

    end_time = time.time()

    return weights, cost_function_values, end_time - start_time

def pairwise_frank_wolfe_markowitz(covariance_matrix, landa, mue, mue_beta):
    # find the total number of asset
    num_assets = len(mue)

    # Start with an initial allocation of 1/n weights
    weights = np.ones((num_assets,1)) / num_assets
    #print("initial weights shape is, ", weights.shape)

    # Defining convergence criteria here
    max_iterations = 20
    tolerance = 1e-3

    # Variables to store the cost function values
    cost_function_values = []

    # Start of the process
    start_time = time.time()

    # Definig the Identity matrix
    Indentity_matrix = np.identity(num_assets)

    for iteration in range(max_iterations):
        # Calculate the gradient of the cost function
        gradiant = cost_function_gradient(weights, covariance_matrix, landa, mue)
        #print(str(iteration) + " weights shape is, " + str(weights.shape))
        #print(str(iteration) + " gradiant shape is, " +  str(gradiant.shape))

        # Set the step size as it was suggested by the article
        step_size = 1.0 / (iteration + 2)

        # find the first direction
        indx = np.argmin(gradiant)
        direction1 = Indentity_matrix[indx]
        direction1 = direction1.reshape((-1, 1))  # Ensure direction has shape (48, 1)
        #print("direction 1 shape is, ", direction1.shape)

        # find the second direction
        indx = np.argmax(gradiant)
        direction2 = Indentity_matrix[indx]
        direction2 = direction2.reshape((-1, 1))  # Ensure direction has shape (48, 1)
        #print("direction 2 shape is, ", direction1.shape)

        # Decide the Direction (s_t - v_t)
        direction = direction1 - direction2

        # Update portfolio weights
        weights += step_size * (direction - weights)

        # Normalize the weights to ensure they sum to 1
        weights /= np.sum(weights)

        # Calculate the current cost function value
        cost_value = cost_function(weights, covariance_matrix, landa, mue, mue_beta)
        #print(type(cost_value), cost_value[0,0])
        cost_function_values.append(cost_value[0,0])

        # Check for convergence
        if np.linalg.norm(step_size * (direction - weights)) < tolerance:
            break

    end_time = time.time()

    return weights, cost_function_values, end_time - start_time



# The projection function that projects weights so that they sum to 1
def projection_function(weights):
    weights /= np.sum(weights)

    return weights

def projected_gradient_descent(covariance_matrix, landa, mue, mue_beta):
    # Find the total number of assets
    num_assets = len(mue)

    max_iterations=20
    tolerance=1e-3

    # Start with an initial allocation of 1/n weights
    weights = np.ones((num_assets, 1)) / num_assets

    # Variables to store the cost function values
    cost_function_values = []

    # Start of the process
    start_time = time.time()

    for iteration in range(max_iterations):
        # Calculate the gradient of the cost function
        gradient = cost_function_gradient(weights, covariance_matrix, landa, mue)

        alpha=1.0 / (iteration + 2)

        # Update portfolio weights
        weights -= alpha * gradient

        # Projection step
        weights = projection_function(weights)

        # Calculate the current cost function value
        cost_value = cost_function(weights, covariance_matrix, landa, mue, mue_beta)
        cost_function_values.append(cost_value[0, 0])

        # Check for convergence: the norm of the projected gradient
        projected_gradient = cost_function_gradient(weights, covariance_matrix, landa, mue) - np.sum(cost_function_gradient(weights, covariance_matrix, landa, mue)) / num_assets
        if np.linalg.norm(projected_gradient) < tolerance:
            break

    end_time = time.time()

    return weights, cost_function_values, end_time - start_time


# The covariance matrix
covariance_matrix = np.array(Cov48)
#print("covariance_matrix shape is, " , covariance_matrix.shape)

# Defining landa
landa = 0.001

# Defining expected rate of return vector
mue = np.array(MRet48)
#print("mue shape is, ", mue.shape)

# Definig the accepted baseline
mue_beta = mue.mean()

print('###############')
print('# Frank Wolfe #')
print('###############')

# Run the Markowitz portfolio optimization to minimize risk
optimal_weights_FW_EUROSTOXX, cost_values_FW_EUROSTOXX, execution_time_FW_EUROSTOXX = frank_wolfe_markowitz(covariance_matrix, landa, mue, mue_beta)

# Calculate the portfolio risk (standard deviation)
portfolio_risk_FW_EUROSTOXX = np.sqrt(np.dot(optimal_weights_FW_EUROSTOXX.T, np.dot(covariance_matrix, optimal_weights_FW_EUROSTOXX)))

# Print the results
print("Frank Wolfe Optimal Portfolio Weights:", optimal_weights_FW_EUROSTOXX.T)
print("Frank Wolfe Optimal Portfolio Risk (Standard Deviation):", portfolio_risk_FW_EUROSTOXX)
print("Frank Wolfe Execution Time (seconds):", execution_time_FW_EUROSTOXX)

########################
# Pairwise Frank Wolfe #
########################
print('########################')
print('# Pairwise Frank Wolfe #')
print('########################')

# Run the Pairwise Markowitz portfolio optimization to minimize risk
optimal_weights_PFW_EUROSTOXX, cost_values_PFW_EUROSTOXX, execution_time_PFW_EUROSTOXX = pairwise_frank_wolfe_markowitz(covariance_matrix, landa, mue, mue_beta)

# Calculate the portfolio risk (standard deviation)
portfolio_risk_PFW_EUROSTOXX = np.sqrt(np.dot(optimal_weights_PFW_EUROSTOXX.T, np.dot(covariance_matrix, optimal_weights_PFW_EUROSTOXX)))

# Print the results
print("Pairwise Frank Wolfe Optimal Portfolio Weights:", optimal_weights_PFW_EUROSTOXX.T)
print("Pairwise Frank Wolfe Optimal Portfolio Risk (Standard Deviation):", portfolio_risk_PFW_EUROSTOXX)
print("Pairwise Frank Wolfe Execution Time (seconds):", execution_time_PFW_EUROSTOXX)


##########################
# Projected Gradient Descent #
##########################
print('##############################')
print('# Projected Gradient Descent #')
print('##############################')

# Run the Projected Gradient Descent algorithm
optimal_weights_PGD_EUROSTOXX, cost_values_PGD_EUROSTOXX, execution_time_PGD_EUROSTOXX = projected_gradient_descent(covariance_matrix, landa, mue, mue_beta)

# Calculate the portfolio risk (standard deviation)
portfolio_risk_PGD_EUROSTOXX = np.sqrt(np.dot(optimal_weights_PGD_EUROSTOXX.T, np.dot(covariance_matrix, optimal_weights_PGD_EUROSTOXX)))

# Print the results
print("Projected Gradient Descent Optimal Portfolio Weights:", optimal_weights_PGD_EUROSTOXX.T)
print("Projected Gradient Descent Optimal Portfolio Risk (Standard Deviation):", portfolio_risk_PGD_EUROSTOXX)
print("Projected Gradient Descent Execution Time (seconds):", execution_time_PGD_EUROSTOXX)

# Plot the changes in the cost function during each iteration
a, = plt.plot(range(len(cost_values_FW_EUROSTOXX)), cost_values_FW_EUROSTOXX, marker='o', linestyle='-', color='b')
b, = plt.plot(range(len(cost_values_PFW_EUROSTOXX)), cost_values_PFW_EUROSTOXX, marker='^', linestyle='--', color='r')
c, = plt.plot(range(len(cost_values_PGD_EUROSTOXX)), cost_values_PGD_EUROSTOXX, marker='s', linestyle='-.', color='g')
plt.xlabel('Iteration')
plt.ylabel('Cost Function Value')
plt.title('EUROSTOXX_50 Cost Function Convergence')
plt.legend([a, b, c], ['FW', 'PFW', 'PGD'])
plt.grid(True)
plt.show()


# The covariance matrix
covariance_matrix = np.array(Cov79)
#print("covariance_matrix shape is, " , covariance_matrix.shape)

# Defining landa
landa = 0.1

# Defining expected rate of return vector
mue = np.array(MRet79)
#print("mue shape is, ", mue.shape)

# Definig the accepted baseline
mue_beta = mue.mean()

print('###############')
print('# Frank Wolfe #')
print('###############')

# Run the Markowitz portfolio optimization to minimize risk
optimal_weights_FW_FTSE, cost_values_FW_FTSE, execution_time_FW_FTSE = frank_wolfe_markowitz(covariance_matrix, landa, mue, mue_beta)

# Calculate the portfolio risk (standard deviation)
portfolio_risk_FW_FTSE = np.sqrt(np.dot(optimal_weights_FW_FTSE.T, np.dot(covariance_matrix, optimal_weights_FW_FTSE)))

# Print the results
print("Frank Wolfe Optimal Portfolio Weights:", optimal_weights_FW_FTSE.T)
print("Frank Wolfe Optimal Portfolio Risk (Standard Deviation):", portfolio_risk_FW_FTSE)
print("Frank Wolfe Execution Time (seconds):", execution_time_FW_FTSE)

print('########################')
print('# Pairwise Frank Wolfe #')
print('########################')

# Run the Pairwise Markowitz portfolio optimization to minimize risk
optimal_weights_PFW_FTSE, cost_values_PFW_FTSE, execution_time_PFW_FTSE = pairwise_frank_wolfe_markowitz(covariance_matrix, landa, mue, mue_beta)

# Calculate the portfolio risk (standard deviation)
portfolio_risk_PFW_FTSE = np.sqrt(np.dot(optimal_weights_PFW_FTSE.T, np.dot(covariance_matrix, optimal_weights_PFW_FTSE)))


# Print the results
print("Pairwise Frank Wolfe Optimal Portfolio Weights:", optimal_weights_PFW_FTSE.T)
print("Pairwise Frank Wolfe Optimal Portfolio Risk (Standard Deviation):", portfolio_risk_PFW_FTSE)
print("Pairwise Frank Wolfe Execution Time (seconds):", execution_time_PFW_FTSE)

##########################
# Projected Gradient Descent #
##########################
print('##############################')
print('# Projected Gradient Descent #')
print('##############################')

# Run the Projected Gradient Descent algorithm
optimal_weights_PGD_FTSE, cost_values_PGD_FTSE, execution_time_PGD_FTSE = projected_gradient_descent(covariance_matrix, landa, mue, mue_beta)

# Calculate the portfolio risk (standard deviation)
portfolio_risk_PGD_FTSE = np.sqrt(np.dot(optimal_weights_PGD_FTSE.T, np.dot(covariance_matrix, optimal_weights_PGD_FTSE)))

# Print the results
print("Projected Gradient Descent Optimal Portfolio Weights:", optimal_weights_PGD_FTSE.T)
print("Projected Gradient Descent Optimal Portfolio Risk (Standard Deviation):", portfolio_risk_PGD_FTSE)
print("Projected Gradient Descent Execution Time (seconds):", execution_time_PGD_FTSE)

# Plot the changes in the cost function during each iteration
a, = plt.plot(range(len(cost_values_FW_FTSE)), cost_values_FW_FTSE, marker='o', linestyle='-', color='b')
b, = plt.plot(range(len(cost_values_PFW_FTSE)), cost_values_PFW_FTSE, marker='^', linestyle='--', color='r')
c, = plt.plot(range(len(cost_values_PGD_FTSE)), cost_values_PGD_FTSE, marker='s', linestyle='-.', color='g')
plt.xlabel('Iteration')
plt.ylabel('Cost Function Value')
plt.title('FTSE_100 Cost Function Convergence')
plt.legend([a, b, c], ['FW', 'PFW', 'PGD'])
plt.grid(True)
plt.show()

# Create a 1x2 subplot grid
plt.figure(figsize=(12, 5))
# Plot the changes in the cost function during each iteration for EUROSTOXX_50
plt.subplot(1, 2, 1)
a, = plt.plot(range(len(cost_values_FW_EUROSTOXX)), cost_values_FW_EUROSTOXX, marker='o', linestyle='-', color='b')
b, = plt.plot(range(len(cost_values_PFW_EUROSTOXX)), cost_values_PFW_EUROSTOXX, marker='^', linestyle='--', color='r')
c, = plt.plot(range(len(cost_values_PGD_EUROSTOXX)), cost_values_PGD_EUROSTOXX, marker='s', linestyle='-.', color='g')
plt.xlabel('Iteration')
plt.ylabel('Cost Function Value')
plt.title('EUROSTOXX_50 Cost Function Convergence')
plt.legend([a,b,c], ['FW', 'PFW', 'PGD'])
plt.grid(True)
# Plot the changes in the cost function during each iteration for FTSE_100
plt.subplot(1, 2, 2)
a, = plt.plot(range(len(cost_values_FW_FTSE)), cost_values_FW_FTSE, marker='o', linestyle='-', color='b')
b, = plt.plot(range(len(cost_values_PFW_FTSE)), cost_values_PFW_FTSE, marker='^', linestyle='--', color='r')
c, = plt.plot(range(len(cost_values_PGD_FTSE)), cost_values_PGD_FTSE, marker='s', linestyle='-.', color='g')
plt.xlabel('Iteration')
plt.ylabel('Cost Function Value')
plt.title('FTSE_100 Cost Function Convergence')
plt.legend([a,b,c], ['FW', 'PFW', 'PGD'])
plt.grid(True)
plt.tight_layout()
plt.show()